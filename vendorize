#!/usr/bin/env python3
# -*- mode: python; -*-
#
# Copyright 2018 Canonical, Ltd.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This package is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# from launchpadlib.launchpad import Launchpad
import yaml
# import requests
from urllib.parse import urlparse
import os
import shutil
import subprocess
import sys

# launchpad = Launchpad.login_anonymously(
#     'snapcraft-yaml-usage', 'production', version='devel')


# Error handling
class Error(Exception):

    def __init__(self, msg):
        super().__init__('Error: {!s}'.format(msg))


# Known snapcraft.yaml file locations
paths = ['snapcraft.yaml', '.snapcraft.yaml', 'snap/snapcraft.yaml']
project_folder = os.getcwd()
dry_run = False
if (len(sys.argv) > 1):
    # Target branch
    target = sys.argv[1]
    # Project in current or specified directory
    if (len(sys.argv) > 2):
        project_folder = sys.argv[2]
        os.chdir(project_folder)
        if (len(sys.argv) > 3):
            dry_run = True
    project_folder = os.path.abspath(project_folder)
else:
    print('Usage: vendorize TARGET_BRANCH [DIRECTORY]')
    sys.exit(1)


def locate_path(project_folder):
    for path in paths:
        try:
            process_yaml(project_folder, path)
            sys.exit(0)
        except Error as e:
            print(e)
            sys.exit(1)
        except Exception as e:
            raise e


def process_yaml(project_folder, path):
    vendoring = os.path.join(project_folder, 'snap', 'vendoring')
    os.makedirs(vendoring, exist_ok=True)
    vendored_source = os.path.join(project_folder, 'snap', 'vendoring', 'src')
    if not os.path.exists(vendored_source):
        copy_source(project_folder, vendored_source)

    with open(path) as f:
        data = yaml.load(f)
        print('Processing {!r}...'.format(path))
        # Allowed hosts for this snap
        allowed_hosts = data.get('vendoring', ['git.launchpad.net'])
        data['vendoring'] = allowed_hosts
        parts = data['parts']
        for part in data['parts']:
            part_data = parts[part]
            source = part_data.get('source', '.')
            source_copy = os.path.join(project_folder, 'parts', part, 'src')
            print('...{!s} ({!r})'.format(part, source))
            if host_not_vendorized(source, allowed_hosts):
                if not dry_run and not os.path.exists(source_copy):
                    if False and 'git' in source:
                        os.makedirs(source_copy)
                        subprocess.check_call(['git', 'clone',
                                               source, source_copy])
                    else:
                        os.chdir(project_folder)
                        subprocess.check_call(['snapcraft', 'pull', part])
                data['parts'][part]['source'] = upload_source(
                    [data['name'], part], source_copy, target)
            # FIXME: plugin is required BUT we're not parsing remote parts
            plugin = part_data.get('plugin', 'nil')
            if plugin in ['python', 'python2', 'python3']:
                data['parts'][part]['python-packages'] = process_python(
                    data, part, allowed_hosts, source,
                    os.path.join(project_folder, 'parts', part))
            elif plugin not in ['copy', 'dump', 'nil']:
                raise Error("No vendoring for {!r}".format(plugin))

    with open(os.path.join(vendored_source, path), 'w') as f:
        yaml.dump(data, f, default_flow_style=False)
        upload_source([data['name']], vendored_source, target,
                      commit='Vendor {}'.format(data['name']))


def copy_source(source, destination):
    for f in os.listdir(path=source):
        # FIXME: Hack to avoid infinitely recursing into snap/vendoring
        if f == 'snap':
            continue
        a = os.path.join(source, f)
        b = os.path.join(destination, f)
        print('{!r} => {!r}'.format(a, b))
        if os.path.isdir(a):
            shutil.copytree(a, b)
        else:
            shutil.copy(a, b)


def process_python(data, part, allowed_hosts, source, source_copy):
    branches = []
    part_data = data['parts'][part]
    python_packages = part_data.get('python-packages', [])
    requirements = part_data.get('requirements')
    if requirements:
        if host_not_vendorized(requirements, allowed_hosts):
            print('* Requirements need to be moved')
        with open(requirements) as r:
            for line in r:
                package = line.strip().split()[-1]
                python_packages.append(package)
    packages_from_setup_py(os.path.join(source, 'setup.py'))
    if python_packages:
        python_cache = os.path.join(source_copy, 'python-packages')
        for package in python_packages:
            branch = upload_python_package(
                [data['name'], part, 'python-packages', package],
                os.path.join(python_cache, package), target)
            branches.append(branch)
    return branches


def upload_python_package(path, copy, target):
    package = path[-1]
    if not dry_run:
        if not os.path.exists(copy):
            os.makedirs(copy)
        subprocess.check_call(['pip', 'download', '-d', copy, package])
        os.chdir(copy)
        subprocess.check_call(['git', 'init'])
    return upload_source(path, copy, target,
                         commit='Vendor {}'.format(package))


def upload_source(path, copy, target, commit=None):
    source_schema = '{}/{}'.format(target, path[0])
    branch = '_'.join(path)
    print('* Uploading {!r} to {!r}'.format(copy, source_schema))
    if not dry_run:
        os.chdir(copy)
        subprocess.check_call(['git', 'checkout', '-B', branch])
        if commit:
            subprocess.check_call(['git', 'add', '--all'])
            subprocess.check_call(['git', 'commit', '--allow-empty',
                                   '-m', commit])
        subprocess.check_call(['git', 'push', '-u', source_schema, branch])
    return '{}@{}'.format(target, branch)


def packages_from_setup_py(setup_py):
    if not os.path.exists(setup_py):
        return

    # Try using setuptools to get install_requires
    import setuptools

    def setup(*args, **kwargs):
        # FIXME
        print('setup: {!r}'.format(kwargs))
    setuptools.setup = setup
    try:
        setup_py_code = open(setup_py.read())
        exec(setup_py_code)
    except Exception as e:
        try:
            stripped_code = ''
            for line in open(setup_py):
                if 'import' not in line:
                    stripped_code += line
        except Exception as e:
            # Fallback to manual scraping for install_requires
            import re
            packages = re.search(r"^install_requires=['\"]([^'\"]*)['\"]",
                                 setup_py_code, re.M)
            if packages:
                print(packages.group(1))
            else:
                raise Error('Failed to parse {!r}: {}'.format(setup_py, e))


def host_not_vendorized(location, allowed_hosts):
    url = urlparse(location)
    host = url.netloc
    return host and host not in allowed_hosts


if __name__ == '__main__':
    locate_path(project_folder)
